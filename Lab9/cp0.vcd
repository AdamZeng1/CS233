$date
	Sun Oct 29 18:11:46 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module cp0_test $end
$var wire 32 ! rd_data [31:0] $end
$var wire 1 " TakenInterrupt $end
$var wire 30 # EPC [29:0] $end
$var reg 1 $ ERET $end
$var reg 1 % MTC0 $end
$var reg 1 & TimerInterrupt $end
$var reg 1 ' clock $end
$var reg 30 ( next_pc [29:0] $end
$var reg 5 ) regnum [4:0] $end
$var reg 1 * reset $end
$var reg 32 + wr_data [31:0] $end
$scope module c0 $end
$var wire 1 $ ERET $end
$var wire 1 % MTC0 $end
$var wire 1 " TakenInterrupt $end
$var wire 1 & TimerInterrupt $end
$var wire 1 , cause_status $end
$var wire 1 ' clock $end
$var wire 1 - epc_register_enable $end
$var wire 1 . exception_level_reset $end
$var wire 30 / next_pc [29:0] $end
$var wire 5 0 regnum [4:0] $end
$var wire 1 * reset $end
$var wire 1 1 sr1_not $end
$var wire 1 2 status_out $end
$var wire 32 3 wr_data [31:0] $end
$var wire 32 4 user_status [31:0] $end
$var wire 32 5 status_register [31:0] $end
$var wire 32 6 rd_data [31:0] $end
$var wire 1 7 exception_level $end
$var wire 32 8 epc_extend [31:0] $end
$var wire 32 9 decoder_out [31:0] $end
$var wire 30 : d_epc_register [29:0] $end
$var wire 32 ; cause_register [31:0] $end
$var wire 30 < EPC [29:0] $end
$scope module decoderRegnum $end
$var wire 1 % enable $end
$var wire 5 = in [4:0] $end
$var wire 32 > out [31:0] $end
$upscope $end
$scope module epcRegister $end
$var wire 1 ' clk $end
$var wire 1 - enable $end
$var wire 1 * reset $end
$var wire 30 ? d [29:0] $end
$var reg 30 @ q [29:0] $end
$upscope $end
$scope module exceptionLevel $end
$var wire 1 ' clk $end
$var wire 1 A d $end
$var wire 1 " enable $end
$var wire 1 . reset $end
$var reg 1 7 q $end
$upscope $end
$scope module muxRdDtata $end
$var wire 32 B A [31:0] $end
$var wire 32 C B [31:0] $end
$var wire 32 D C [31:0] $end
$var wire 2 E sel [1:0] $end
$var wire 32 F wAB [31:0] $end
$var wire 32 G out [31:0] $end
$scope module mAB $end
$var wire 32 H A [31:0] $end
$var wire 32 I B [31:0] $end
$var wire 32 J out [31:0] $end
$var wire 1 K sel $end
$var wire 32 L temp1 [31:0] $end
$var wire 32 M temp2 [31:0] $end
$upscope $end
$scope module mfinal $end
$var wire 32 N A [31:0] $end
$var wire 32 O B [31:0] $end
$var wire 32 P out [31:0] $end
$var wire 1 Q sel $end
$var wire 32 R temp1 [31:0] $end
$var wire 32 S temp2 [31:0] $end
$upscope $end
$upscope $end
$scope module muxTI $end
$var wire 30 T A [29:0] $end
$var wire 30 U B [29:0] $end
$var wire 30 V out [29:0] $end
$var wire 1 " sel $end
$var wire 30 W temp1 [29:0] $end
$var wire 30 X temp2 [29:0] $end
$upscope $end
$scope module userStatus $end
$var wire 1 ' clk $end
$var wire 32 Y d [31:0] $end
$var wire 1 Z enable $end
$var wire 1 * reset $end
$var reg 32 [ q [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx [
0Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0xxxxxxxx000000xx R
0Q
b0xxxxxxxx000000xx P
bx00 O
b0xxxxxxxx000000xx N
b0 M
b0xxxxxxxx000000xx L
0K
b0xxxxxxxx000000xx J
b0 I
b0xxxxxxxx000000xx H
b0xxxxxxxx000000xx G
b0xxxxxxxx000000xx F
b0 E
bx00 D
b0 C
b0xxxxxxxx000000xx B
1A
bx @
b0 ?
b0 >
b0 =
bx <
b0 ;
b0 :
b0 9
bx00 8
x7
b0xxxxxxxx000000xx 6
b0xxxxxxxx000000xx 5
bx 4
b0 3
x2
x1
b0 0
b0 /
1.
0-
0,
b0 +
1*
b0 )
b0 (
0'
0&
0%
0$
bx #
0"
b0xxxxxxxx000000xx !
$end
#5
b0 !
b0 6
b0 G
b0 P
02
b0 R
11
b0 F
b0 J
b0 N
b0 L
b0 4
b0 [
b0 8
b0 D
b0 O
b0 #
b0 <
b0 @
b0 5
b0 B
b0 H
07
1'
#10
b111111111111111111111111111111 :
b111111111111111111111111111111 ?
b111111111111111111111111111111 V
b111111111111111111111111111111 W
1Z
b111111111111111111111111111111 T
b1000000000000 9
b1000000000000 >
0.
0'
b11111111111111111111111111111111 +
b11111111111111111111111111111111 3
b11111111111111111111111111111111 Y
b1100 )
b1100 0
b1100 =
1%
0*
#15
b1111111100000001 !
b1111111100000001 6
b1111111100000001 G
b1111111100000001 P
b1111111100000001 R
12
b1111111100000001 F
b1111111100000001 J
b1111111100000001 N
b1111111100000001 L
b1111111100000001 5
b1111111100000001 B
b1111111100000001 H
b11111111111111111111111111111111 4
b11111111111111111111111111111111 [
1'
#20
0Z
b0 9
b0 >
0'
0%
#25
1'
#30
b100000000000000000100 :
b100000000000000000100 ?
b100000000000000000100 V
b0 W
b100000000000000000100 X
1-
1"
1,
0'
b100000000000000000100 (
b100000000000000000100 /
b100000000000000000100 U
b1000000000000000 ;
b1000000000000000 C
b1000000000000000 I
1&
#35
b111111111111111111111111111111 :
b111111111111111111111111111111 ?
b111111111111111111111111111111 V
b111111111111111111111111111111 W
b0 X
0-
0"
b1111111100000011 !
b1111111100000011 6
b1111111100000011 G
b1111111100000011 P
02
b1111111100000011 R
01
b1111111100000011 F
b1111111100000011 J
b1111111100000011 N
b1111111100000011 L
b1111111100000011 5
b1111111100000011 B
b1111111100000011 H
17
b10000000000000000010000 8
b10000000000000000010000 D
b10000000000000000010000 O
b100000000000000000100 #
b100000000000000000100 <
b100000000000000000100 @
1'
#40
0'
b100000000000000001000 (
b100000000000000001000 /
b100000000000000001000 U
#45
1'
#50
b10000000000000000010000 !
b10000000000000000010000 6
b10000000000000000010000 G
b10000000000000000010000 P
b0 R
b10000000000000000010000 S
1Q
b10 E
0'
b1110 )
b1110 0
b1110 =
#55
1'
#60
b1000000000000000 F
b1000000000000000 J
b1000000000000000 N
b1000000000000000 !
b1000000000000000 6
b1000000000000000 G
b1000000000000000 P
b0 L
b1000000000000000 M
b1000000000000000 R
b0 S
1K
0Q
b1 E
0'
b1101 )
b1101 0
b1101 =
#65
1'
#70
b0 !
b0 6
b0 G
b0 P
b0 R
0,
b0 F
b0 J
b0 N
1.
b0 M
0'
1$
b0 ;
b0 C
b0 I
0&
#75
12
11
b1111111100000001 5
b1111111100000001 B
b1111111100000001 H
07
1'
#80
b1111111100000001 !
b1111111100000001 6
b1111111100000001 G
b1111111100000001 P
b1111111100000001 R
b1111111100000001 F
b1111111100000001 J
b1111111100000001 N
b1111111100000001 L
0K
b0 E
0'
b1100 )
b1100 0
b1100 =
#85
1'
#90
b0 !
b0 6
b0 G
b0 P
b0 R
b0 F
b0 J
b0 N
b0 L
1K
b1 E
0'
b1101 )
b1101 0
b1101 =
#95
1'
#100
0'
